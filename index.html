<html>
<meta charset="utf-8"/>
<meta name="viewport" content="initial-scale=1.0, width=device-width" />
<title>Nekoka</title>
<style type="text/css">
/* The navigation bar */
.navbar {
  padding: 10 0 10 0;
  background-color: #ffffffdd;
  overflow: hidden;
  position: fixed;
  top: 0;
  width: 100%;
}

a:link { color: #003399; text-decoration: none }
a:visited { color: #0066cc; text-decoration: none }
a:active {  color: #0099ff; text-decoration: none }
body {
  font-family: Geneva, Arial, Helvetica, sans-serif;
  color: #000000;
  background-color: white;
}
li {
  margin: 7 0;
}
.narrowlist li {
  margin: 2 0;
}
</style>
</html>

<body>

<div class="navbar">
<table>
<tr valign=top><td width=100>
<td>
<a href="#">Home</a> &nbsp;&nbsp;
<a href="#summary">Summary</a> &nbsp;&nbsp;
<a href="#context">Context</a> &nbsp;&nbsp;
<a href="#goals">Goals</a> &nbsp;&nbsp;
<a href="#team">Team</a> &nbsp;&nbsp;
<a href="#events">Events</a> &nbsp;&nbsp;
<a href="#papers">Papers</a> &nbsp;&nbsp;
<a href="#contact">Contact</a>
<td width=100>
</table>
</div>

<br><br><br><br>

<table>
<tr valign=top><td width=100>
<font color="#dddddd" size=4>
<td>

<h1>Nekoka<br>
<font size=5>Realizing the Promise of Higher-Order SMT and Superposition for Interactive Verification</font>
</h1>

<br>

<div class="container">
<p>
<table>
<tr><td rowspan=3 align=right valign=center><img src="eu_flag_yellow_low.jpg" width="100px" border="0" name="European Union flag">&nbsp;&nbsp;&nbsp;
<td><font size=+1><a href="https://erc.europa.eu">European Research Council (ERC) Consolidator Grant 2022</a></font>
	<tr><td colspan=2>Grant Agreement No. 101083038
<tr><td colspan=2>July 2023 &ndash; June 2028
<tr><td>&nbsp;
<tr><td>&nbsp;
<!-- TODO: Fix my home page. -->
<tr><td align=right><i>Principal&nbsp;investigator:</i>&nbsp;&nbsp;
  <td><a href="https://people.mpi-inf.mpg.de/~jblanche/">Jasmin Blanchette</a> <!--, Ludwig-Maximilians-Universität München-->
<tr><td align=right><i>Host institution:</i>&nbsp;&nbsp;
  <td><a href="https://www.lmu.de/en/index.html">Ludwig-Maximilians-Universität München</a>, Germany
</table>
</div>

<br>
<br>
<br>
<a name="summary">
<h2>Summary</h2>

<p>Proof assistants (also called interactive theorem provers) have a long
history of being very tedious to use. The situation has improved markedly with
the integration of first-order automatic theorem provers as
backends. And recently, there have been exciting developments for more
expressive logics, with the emergence of automatic provers based on optimized
higher-order calculi. The Nekoka project's aim is to make higher-order SMT and
λ-superposition a great fit for logical problems emerging from the verification
of software and mathematics.</p>

<p>We will start by extending higher-order SMT and λ-superposition and
implementing these extensions in automatic provers to provide push-button proof
automation for lemmas expressed in higher-order logics. To reach end users, we
will integrate the automatic provers in interactive tools: both general-purpose
proof assistants and software verification platforms. As case studies, we will
use our own provers and integrations to formalize quantum information theory and
verify a big data framework in collaboration with domain experts. Beyond
providing representative case studies, this will help build a user community
around our tools and technologies.</p>

<p>In terms of scientific impact, our hope is that the improved higher-order SMT and
λ-superposition calculi will substantially advance the art of higher-order
automation and help reorient research in automated reasoning towards the needs
of end users, whether computer scientists or mathematicians. Our tools will
outlive the project, serving end users and continuing to be useful for future
research. At the societal level, the project will herald a future in which
automatic provers and proof assistants are routinely deployed in tandem to
verify critical computing infrastructure and to formalize research in computer
science and mathematics, thereby leading to more trustworthy software and
science.</p>

<br>
<br>
<br>
<a name="context">
<h2>Context and state of the art (anno 2023)</h2>

<p>
Theorem proving software has been around for a long time, starting with the
Logic Theorist in 1955. Automatic theorem provers and interactive proof
assistants are used in industry to verify hardware (e.g., by AMD, Centaur
Technologies, Intel) and software (e.g., by Airbus, Amazon, Apple, Facebook,
Google, Microsoft), but compared with other branches of computer science, the
impact of theorem proving on science and industry remains limited.

<p>
A few examples of software verified using theorem provers are the
optimizing C compiler CompCert, the operating system
kernels CertiKOS and seL4, the
conference management system CoCon, and the SAT
(satisfiability) solver IsaSAT. But despite having been
carried out using Coq and Isabelle, two modern proof assistants, these efforts
were very time consuming. For example, verifying less than 10 000 lines of
code took the seL4 team around 20 person-years, and the pure
mathematicians who have embraced the Lean proof assistant, notably Kevin Buzzard,
report that formally verifying a single &ldquo;obvious&rdquo; step can take an
arbitrarily long time. To most potential users, the tools are not yet
cost-effective.

<p>
The current situation is unfortunate, to say the least. Writing a pen-and-paper
proof is akin to developing a program as pseudocode, without using a compiler or
an integrated development environment. The process is awkward and error-prone.
Despite its weaknesses, existing theorem proving software can already be
useful to many computer scientists, engineers, and even mathematicians.
Computers outperform humans for complex logical reasoning tasks, which are
crucial in many areas.

<p>
The Nekoka project's vision is to develop highly flexible interactive
verification tools that incorporate very strong proof automation, broadening
the range of problems for which computers can assist humans. Proof steps
that are obvious to the user but currently require hours of focused labor will
become largely or fully automatic. These tools will support general-purpose
reasoning and combinations of proof techniques. They will revolutionize the
practice of software verification and formalized mathematics.

<blockquote style="background-color: #f7f7f7;">
<b>Example 1.</b>
To show the gulf between the state of the art and the vision, we consider
the CoCon conference management system, which was verified to
ensure the absence of leaks. Below is the Isabelle proof of the claim that program committee
members cannot review papers if they have a conflict of interest:

<blockquote>
proof <font style="background-color: #ffe4f1;">(cases a)</font><br>
&nbsp;&nbsp;case (Create c)<br>
&nbsp;&nbsp;show ?thesis<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font style="background-color: #ffe4f1;">using Step isRev reach.Step by simp</font><br>
next<br>
&nbsp;&nbsp;case (Update u)<br>
&nbsp;&nbsp;show ?thesis<br>
&nbsp;&nbsp;proof <font style="background-color: #ffe4f1;">(cases u)</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;case (UpdatePref confID uID p paperID pref)<br>
&nbsp;&nbsp;&nbsp;&nbsp;thus ?thesis<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="background-color: #ffe4f1;">using Step unfolding Update UpdatePref isRev_def2</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="background-color: #ffe4f1;">by (blast dest: isRevNth reach.Step)</font><br>
&nbsp;&nbsp;qed<br>
next<br>
&nbsp;&nbsp;case (NondestUpdate nu)<br>
&nbsp;&nbsp;show ?thesis<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font style="background-color: #ffe4f1;">using Step unfolding NondestUpdate isRev_def2</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;<font style="background-color: #ffe4f1;">by (meson IO.reach.Step isRevNth)</font><br>
qed <font style="background-color: #ffe4f1;">simp+</font>
</blockquote>

<p>
Isabelle proofs are hierarchical and exhibit a block structure reflected by the
indentation. The parts highlighted in pink, supplied by the user, correspond to
the actual proof steps; they required some thinking and interactions with the
system. The rest specifies the proof outline: a three-way case
analysis, whose second case is itself a case analysis. The three outer cases
are labeled Create, Update, and NondestUpdate.

<p>
The proof may easily have taken 15 minutes to develop. It combines various
types of automation. User productivity would skyrocket if such proofs could be
entirely generated at the click of a button.
</blockquote>

<p>
Today we see several elements of the above vision in a variety of tools. The
most widely deployed theorem provers are likely SAT and
SMT (satisfiability modulo theories) solvers.
Their great strength is
that they are reliable enough to serve as backends to dozens of software
verification and testing platforms as a push-button technology.
On the other hand,
their logics are restrictive. Users often find it more convenient to express
their problems in higher-order logics such as simple type theory and dependent
type theory. HOSMT (higher-order SMT) has
been proposed but is in its infancy.
Next to SAT and SMT solvers, another family of
successful automatic provers consists of those based on the superposition
calculus,
a successor of the resolution calculus.

<p>
At the other end of the automatic–interactive spectrum, we have the proof
assistants, most of which are based on simple or dependent type theory. These
tools offer a graphical user interface that can be used to develop large proofs
interactively. Their richer logic makes it possible to use higher-order
functions (e.g., map and fold on lists), big operators, set comprehensions, the
big O notation, monads, and more.

<p>
SMT solvers and superposition provers are integrated as backends to proof
assistants to increase the level of automation. Such integrations are called
<em>hammers</em>. Hammers encode the problem in the automatic
provers' less expressive logic and translate any proofs found in the other
direction. In Example 1, the &ldquo;by (meson IO...)&rdquo; command near the end
was generated by Sledgehammer, the hammer for Isabelle.

<p>
For a long time, the most successful hammer backends supported only first-order
logic, but recently there has been a breakthrough in the development of
strong higher-order automatic provers. To see this, it suffices to take a look
at the results of the higher-order division of the 2020 edition of the CASC
prover competition:

<center>
<table style="background-color: #f7f7f7;">
<tr>
<th>
<th align=center>&nbsp;Zipperposition&nbsp;
<th align=center>&nbsp;Satallax&nbsp;
<th align=center>&nbsp;Vampire&nbsp;
<th align=center>&nbsp;Leo-III&nbsp;
<th align=center>&nbsp;CVC4&nbsp;
<th align=center>&nbsp;Leo-II&nbsp;
<tr>
<th>Solved problems (of 500)
<td align=center><b>424</b>
<td align=center>323
<td align=center>299
<td align=center>287
<td align=center>194
<td align=center>111
</table>
</center>

<p>
A cell containing <em>n</em> tells us that the prover solved
<em>n</em> out of 500 problems with a wall-clock
time limit of 120 s per problem.
Leo-II
represents the state of the art five years ago. Since then,
Satallax—the leader until 2019—has gained a lot of ground,
and a new generation of
higher-order provers has emerged: the winning Zipperposition,
developed by the
<a href="https://matryoshka-project.github.io/">Matryoshka team</a> and based on λ-superposition,
and also Vampire,
Leo-III,
and CVC4 (now cvc5),
developed by other teams.
The results from CASC 2021 and 2022 only confirmed this picture.
In the past five years or so, strong higher-order automation has taken the step
from music of the future to reality.

<p>
This line of work has produced remarkable results, but it has also raised new
scientific questions and opened up new possibilities. Reliable push-button proof
automation for typical real-world applications (as opposed to the logical
puzzles that are common among CASC benchmarks) now seems within reach. But to
make <em>this</em> a reality, we must overcome the following challenges:

<ul>
<li> <b>Out of tune:</b>
  Higher-order automatic provers today are almost exclusively tuned against the
  benchmark library used for CASC. They disappoint on problems originating from
  hammers, which tend to be fundamentally less higher-order but involve hundreds
  of superfluous axioms.

<li> <b>Lost in deduction:</b>
  The most successful theorem proving approaches replace heuristic deduction by
  focused computation wherever they can. SMT solvers with their support for
  decidable theories are a prime example. Nobody has yet looked into the
  optimization of big operators and many other practical
  higher-order theories.

<li> <b>No dependent types:</b>
  The proof assistants Agda, Coq, and Lean are based on dependent type theory,
  but higher-order provers support only simple types. Dependent types are useful
  for
  <em>m</em> &times; <em>n</em> matrices,
  integers modulo <em>n</em>,
  families (<em>X<sub>i</sub></em>)<em><sub>i</sub></em>,
  and
  <em>p</em>-adic numbers.
  Today they must be translated using
  clumsy, inefficient encodings.

<li> <b>Opaque failures:</b>
  Successful solvers typically give users some information, such as a potential
  countermodel, on failure. However, the current
  generation of higher-order provers provide no guidance when they time out.
</ul>

<p>
Exciting higher-order reasoning techniques are emerging in automatic theorem
provers, which could lead to push-button automation in <b>highly efficient
verification tools</b>. More research is needed to develop the potential of these
technologies and deploy them in science and industry.

<p>
Although verification of
all software will never be practical, we should aim at verifying safety- and
security-critical systems, starting with the libraries they build on. The
high-profile bug found in Android's, Java's, and Python's sorting procedure,
detected during verification, is a stark reminder of the
relevance of formal methods. By relying to a greater extent on computers to
develop and check proofs, practitioners and researchers can achieve much higher
quality standards for software and science.

<br>
<br>
<br>
<a name="goals">
<h2>Challenges and objectives</h2>

<p>
Nowadays it is widely acknowledged that formal methods do work. Computer
scientists of any persuasion understand that the seL4 kernel will not panic due
to software bugs, that the CompCert compiler produces correct assembly code, and
that the EverCrypt cryptography library verified using
F* is mathematically correct.

<p>
SAT and SMT solvers are leading the way in industry, and superposition provers
have distinguished themselves as backends to hammers in proof assistants. But users
still face a choice between automation and expressiveness. In an ideal
world, computers and humans would complement each other, doing what they are
best at. But today's automatic and interactive theorem provers are far from
this ideal.

<blockquote style="background-color: #dfedff;">
Our grand challenge is to <b>extend higher-order SMT and superposition</b> to
make them a perfect match for problems emerging from <b>interactive
verification</b>. We will implement these improvements in standalone provers,
integrate them in proof assistants and software verification platforms, and
collaborate with early adopters to deploy our tools.
</blockquote>

<p>
To meet this challenge, we need to build on the strengths of both automatic and
interactive theorem proving. The interactive side includes general-purpose proof
assistants such as Coq, Isabelle, and Lean as well as software verification
platforms such as F* and the TLA<sup>*</sup> Proof System. They all provide some proof
management—checking that definitions are well formed and that every stated
lemma is proved. Developing a proof is much like coding a program in an
integrated development environment. All interactive tools provide some
automation, and when automation fails, users can specify a proof outline like in
Example 1 above. For instance, if the step from lemma <em>L</em>
to lemma <em>N</em> is too difficult, the user can state an intermediate
lemma <em>M</em> and then derive <em>N</em> from <em>M</em> and <em>M</em> from
<em>L</em>. Induction and case analysis must normally be applied by the user as
well.

<p>
The tools on the automatic side have a very different look and feel. They are
command-line programs that try to solve a self-contained input problem within a
given time limit. They can give three verdicts: provable, unprovable, or
unknown. For problems in first-order logic and beyond, due to the logic's
undecidability, the verdict &ldquo;unprovable&rdquo; is very rare. Nevertheless,
SMT solvers can often provide useful potential counterexamples, and the output
of superposition provers could also be analyzed to provide helpful hints to the
user.

<p>
The grand challenge will be met by pursuing three objectives. Our starting point
is that there is a lot of scientific value in pursuing the following activities
within a single team: developing higher-order proof calculi, implementing them
in provers, integrating these in verification platforms, and applying the
platforms to verify specific pieces of software or mathematics. By using our own
tools, we can detect and fix shortcomings as they arise and implement new
features that meet practical needs. It is also important that the techniques and
tools we develop are adopted by others and outlive the project.

<h3>Objective 1: Extend HOSMT and λ-superposition to
provide push-button automation for proof obligations in higher-order logics</h3>

<p>
Our priority will be to make higher-order SMT a working reality. The forthcoming
SMT-LIB 3 standard will support HOSMT, and cvc5 already supports some HOSMT
constructs but not λ-expressions. Despite its
dominance as a first-order solver, cvc5 disappoints in the higher-order division
of CASC.
We will collaborate with the cvc5 developers to enhance their solver. Quantifier
instantiation is crucial for lemmas containing universally
quantified variables, but today it has not been
generalized to full simple type theory. The challenge is to achieve a
graceful generalization, both in theory and in practice, so that the
solver performs well on higher-order formulas while remaining efficient on
first-order formulas.

<p>
In contrast, superposition is known for its efficient quantifier support.
To capitalize on the success of the λ-superposition calculus,
we will investigate its theory, aiming to
reduce its search space without compromising its ability to prove any
provable problem—its <em>refutational completeness</em>.
The focus on refutational completeness as a guide to achieve high performance
will be a distinguishing feature of our work. Some researchers see pragmatism
and completeness as opposites; for us, they will go hand in hand.

<p>
On a scale of expressiveness, simple type theory is located between first-order
logic and dependent type theory. We will work at both ends of this scale. On the
one hand, we will adapt successful SAT and first-order techniques to a
higher-order setting. On the other hand, we will extend λ-superposition
to dependent type theory with the axiom of choice. Both parts of this program
raise their own challenges, because more expressive logics are less well
behaved; when generalizing techniques, we must invariably design workarounds to
compensate. In particular, for dependent type theory, we will need to find
solutions to cope with dependent types, uninhabited types, universes, and
universe polymorphism. To achieve refutational completeness, we will follow the
stratified design that underlies λ-superposition.

<h3>Objective 2: Integrate higher-order provers in interactive verification
platforms, using lightweight, trustworthy translations</h3>

<p>
Rather than being invoked from the command line, automatic provers usually serve
as backends to general-purpose proof assistants or more specialized software
verification platforms. To reach users, we will integrate, and help integrate,
our provers in many interactive proof tools.
On the proof assistant side, our targets will be Isabelle and Lean, as
representatives of simple and dependent type theory.
Isabelle's tool Sledgehammer already includes rudimentary support for
Zipperposition, but Zipperposition has not yet been fine-tuned on Isabelle benchmarks.
For Lean, work has commenced on a Lean Hammer in the Lean community. The main
difficulty on the Lean side will be to design an encoding of dependent types
that is sound, graceful, ideally complete, and efficient.

<p>
To make Sledgehammer and the Lean Hammer more transparent when they fail, we will
have the automatic provers output <b>proofs with holes</b>—for example, if one
of the cases of a proof by case analysis cannot be solved.
In general, because of the heuristic way in which provers explore the search
space, there may be many competing unfinished proof attempts. New
heuristics will be needed to choose among them. Proofs with holes
should work well in combination with clause splitting,
a technique to partition the search space.
When reconstructing proofs in Isabelle or Lean, the hammer will put in a
<font color=red>sorry</font> placeholder for each missing subproof.

<blockquote style="background-color: #f7f7f7;">
<b>Example 2.</b>
Consider the Isabelle proof presented in Example 1. The
envisioned automation might prove all but the most difficult, second case
(Update). A future Sledgehammer would then generate the proof text below:

<blockquote>
<font style="background-color: #ffffbf;">proof (cases a)</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;case (Create c)</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;show ?thesis</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;&nbsp;&nbsp;using Step isRev reach.Step by simp</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;case (Update u)</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;show ?thesis</font><br>
<font style="background-color: #ffffbf;" color=red>&nbsp;&nbsp;&nbsp;&nbsp;sorry</font></font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;case (NondestUpdate nu)</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;show ?thesis</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;&nbsp;&nbsp;using Step unfolding NondestUpdate isRev_def2</font><br>
<font style="background-color: #ffffbf;">&nbsp;&nbsp;&nbsp;&nbsp;by (meson IO.reach.Step isRevNth)</font><br>
<font style="background-color: #ffffbf;">qed simp+</font><br>
</blockquote>

<p>
The user would then remove the <font color=red>sorry</font> and continue manually,
possibly invoking Sledgehammer again to solve new subcases. Clearly, a partial
proof such as this is much more helpful than an opaque failure.
</blockquote>

<p>
For software verification platforms, we face a chicken-and-egg
situation: The vast majority of platforms present users with first-order
formalisms, because they are based on first-order SMT solvers. We will
initially focus on F* and the TLA<sup>+</sup> Proof System.
F* is a dependently typed effectful functional programming language with
features aimed at program verification. The TLA<sup>+</sup> Proof System is a
tool for specifying and verifying concurrent and distributed systems based on
set theory.

<h3>Objective 3: Apply higher-order reasoning methods to
ongoing verification efforts, in close collaboration with quantum information
and big data scientists</h3>

<p>
Tools have a major role to play in stimulating new ideas for improvements and
extensions, but they need users to thrive. To create an immediate impact, we
will collaborate with other Isabelle and Lean users who are working on ambitious
projects formalizing quantum information and a big data framework—two
attractive new topics for formal verification—so that we can work with real
benchmarks and increase awareness of our tools to reach more potential users.
These two areas of research have received comparatively little attention from
the theorem proving community and could benefit greatly from formal
verification.

<p>
Quantum physics has interesting implications for information processing,
including cryptography and problem solving. As a result, quantum information has
become its own area of study. It is highly mathematical and as such constitutes
an interesting target for proof assistants. We will build a Lean library for the
mathematics of quantum information, including libraries for quantum circuits and
quantum information theory. This case study will exercise our tools' support for
dependent types. This will provide valuable case studies to guide our work and
help build a user community around our technologies.

<p>
Big data frameworks can be used to process high volumes of data arriving at high
speed. They manage deployment of parallelizable programs onto the cloud and
provide fault tolerance. Yet they are themselves notoriously faulty, which is
extremely worrying given that they process huge amounts of critical data in
industry. As our second case study, we will use Isabelle to formally verify a
big data framework inspired by Timely Dataflow.

<br>
<br>
<br>
<a name="team">
<h2>The Nekoka Team</h2>

<h3>Funded by the project</h3>

<a href="https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html">Jasmin Blanchette</a>, Ludwig-Maximilians-Universität München<br>
<a href="https://abentkamp.github.io/">Alexander Bentkamp</a>, Ludwig-Maximilians-Universität München
<a href="https://www.tcs.ifi.lmu.de/mitarbeiter/martin-desharnais_de.html">Martin Desharnais</a>, Ludwig-Maximilians-Universität München<br>
<a href="https://www.tcs.ifi.lmu.de/mitarbeiter/yiming-xu_de.html">Yiming Xu</a>, Ludwig-Maximilians-Universität München<br>
<a href="https://www.tcs.ifi.lmu.de/mitarbeiter/xavier-genereux_de.html">Xavier Généreux</a>, Ludwig-Maximilians-Universität München<br>
<a href="https://www.tcs.ifi.lmu.de/mitarbeiter/elisabeth-lempa_de.html">Elisabeth Lempa</a>, Ludwig-Maximilians-Universität München

<h3>Senior collaborators</h3>

<a href="http://www.iro.umontreal.ca/~dupuisf/">Frédéric Dupuis</a>, Université de Montréal<br>
<a href="https://scholar.google.com/citations?user=wU349w0AAAAJ&hl=ja">Gabriel Ebner</a>, Microsoft Research<br>
<a href="https://www.cs.cmu.edu/~mheule/">Marijn Heule</a>, Carnegie Mellon University<br>
<a href="https://homepage.cs.uiowa.edu/~ajreynol/">Andrew Reynolds</a>, University of Iowa<br>
<a href="http://wwwlehre.dhbw-stuttgart.de/~sschulz/DHBW_Stephan_Schulz/Stephan_Schulz.html">Stephan Schulz</a>, DHBW Stuttgart<br>
<a href="https://www.microsoft.com/en-us/research/people/nswamy/">Nikhil Swamy</a>, Microsoft Research<br>
<a href="http://www.mpi-inf.mpg.de/departments/automation-of-logic/people/sophie-tourret/">Sophie Tourret</a>, Inria Nancy<br>
<a href="https://di.ku.dk/english/staff/?pure=en/persons/682552">Dmitriy Traytel</a>, Københavns Universitet

<h3>Acknoweldgments</h3>

<p>
The project is thankful for the support and advice of the following friends and
colleagues:
Jean-Pierre Banâtre,
Alexander Bentkamp,
Simon Cruanes,
Martin Desharnais,
Pascal Fontaine,
Laura Kovács,
Robert Lewis,
Jannis Limperg,
Assia Mahboubi,
Anja Palatzke,
Andrei Popescu,
Trenton Schulz,
Rikkert Stuve,
Mark Summerfield,
Petar Vukmirović,
Uwe Waldmann, and
Aleksandar Zeljić.

<br>
<br>
<br>
<a name="events">
<h2>Events</h2>

TBA

<br>
<br>
<br>
<a name="papers">
<h2>Papers</h2>

<h3>Draft</h3>

<ul>
<li>
<b>Complete and efficient higher-order reasoning via lambda-superposition
<br>Alexander Bentkamp, Jasmin Blanchette, Visa Nummelin, Sophie Tourret, and
Uwe Waldmann.
<br><font size="2"><a href="pubs/sup-lam-sup-intro.pdf">Authors' PDF</a></font>
</ul>

<h3>2023</h3>

<ul>
<b>Verified given clause procedures</b>
<br>Jasmin Blanchette, Qi Qiu, and Sophie Tourret. In Pientka, B., Tinelli, C. <em>29th International Conference on Automated Deduction</em> (CADE-29), LNCS, Springer, 2023.
<br><font size="2"><a href="pubs/given.pdf">Authors' PDF</a></font>

<li>
<b>Finding mathematical proofs using computers</b>
<br>Alexander Bentkamp and Jasmin Blanchette. <em>Nieuw Archief voor Wiskunde</em> <b>5/24</b>(2): 114–118, 2023.
<br><font size="2"><a href="https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette/naw5-2023-24-2-114.pdf">Publisher's PDF</a> &sdot; <a href="pubs/computers.pdf">Authors' PDF</a></font>

</ul>

<br>
<br>
<br>
<a name="contact">
<h2>Contact</h2>

<p>Please contact <a href="https://www21.in.tum.de/~blanchet/">Jasmin
Blanchette</a> if you have inquiries related to the project.<p>

<!-- TODO: Revive.
<br>
<br>
<br>
<div class="sticker">
  <table>
    <tbody><tr>
      <td>&nbsp;
      <td><img src="eu_flag_yellow_low.jpg" width="50px" border="0" name="European Union flag"></td>
      <td>&nbsp;&nbsp;&nbsp;
      <td>This project has received funding from the European Union's Horizon Europe research and innovation program
        under grant agreement No. 101083038.&nbsp;&nbsp;</td>
    </tr>
  </tbody></table>
</div>
-->

<br>
<br>
<br>

<td width=100>
</table>

</body>
